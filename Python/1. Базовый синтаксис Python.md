## Заметка
Все сложные слова со сноской находятся в словаре. Ссылка на [[Словарь]]

Python - это интерпретируемый язык программирования с простой и читаемой синтаксической структурой. Ниже представлены ключевые элементы базового синтаксиса Python.

## Базовый синтаксис и операции в Python 
### Комментарии:
+ Однострочные комментарии начинаются с символа `#` и интерпретатор их игнорирует
+ Многострочные комментарии можно писать в тройных кавычках ` ''' ` или ` """ `, но они обычно используются для docstrings.
### Операторы
+ Арифметические операторы: `+,-,*,/,// (целочисленное деление), % (остаток от деления), ** (возведение в степень).
+ Операторы сравнения `==, !=,>,<,>=,<-`
+ Логические операторы: `and, or, not`
## Условные конструкции
Используются для выполнения кода в зависимости от определенного условия.
```python
a = 10
if a > 5:
	print('a больше 5')
elif a == 5:
	print('a равно 5')
else:
	print('a меньше 5')
```
## Циклы
+ Цикл `for`: используется для интеграции по последовательности (список, строка, кортеж, т.д.)
+ Цикл `while` выполняет блок кода, пока условие истинно.
```python
# Пример с циклом for
for i in range(5):
	print(i) # Вывод: 0,1,2,3,4

# Пример с циклом while
count = 0 
while count < 5:
	print(count)
	count += 1 # Инкремент переменной
```
## Типы данных и их преобразования 
### Числа
+ int: целые числа
+ float: числа с плавающей точкой
+ complex: комплексные числа
### Строки (str) 
Последовательность символов
```python
name = "John"
print(name.upper())
```
### Булевы значения (bool): 
TRUE or FALSE
```python
is_active = True
print(is_active) # True
```
### Списки (list)
Упорядоченные коллекции элементов, которые могут содержать элементы разных типов.
```python
fruits = ["apple", "banana", "cherry"]
print(fruits[0])
```
### Кортежи (tuple): 
Упорядоченные и неизменяемые коллекции элементов.
```python
dimensions = (200, 50)
print(dimansions[0]) #200
```
### Множества (set):
Неупорядоченные коллекции уникальных элементов
```python
unique_numbers = {1,2,3,4,5}
```
### Словари (dict): 
Неупорядоченные коллекции пар "ключ-значение".
```python
student = {"name":"Niki", "age":21}
print(student["name"]) # Niki
```
### NoneType
Специальный тип данных который представляет собой отсутствие значения
```python
value = None
print(value) # None
```
### Преобразование типов
Преобразование типов в Python осуществляется с использованием встроенных функций: `int(), float(), str(), list(), tuple() и т.д.`

### Работа со списками в Python
Списки - это изменяемые последовательности, которые позволяют хранить наборы элементов разных типов.
1. Создание списка: 
```python
fruits = ["apple","banana","cherry"]
```
2. Доступ к элементам списка:
```python
print(fruits[0])
```
3. Изменение элементов:
```python
fruits[] = "blueberry"
print(fruits) # ["apple", "blueberry", "cherry"]
```
4. Добавление элементов: 
+ Метод `append`: добавляет элемент в конец списка
+ Метод `insert`: Вставляет элемент на указанную позицию.
5. Удаление элементов:
+ Метод `remove()`: удаляет первый найденный элемент.
+ Метод `pop()`: удаляет элемент по индексу и возвращает его. 
+ Метод `clear()`: очищает список.
6. Итерация по списку:
```python
for fruit in fruits:
	print(fruit)
```
### Импортирование библиотек
Импортирование библиотек в Python осуществляется с использованием ключевого слова `import`
1. Импортирование стандартных библиотек
```python
import math
print(math.sqrt(16)) # 4.0
```
2. Импортирование определенных функций или классов
```python
from math import sqrt
print(sqrt(25)) # 5.0
```
3. Импортированные библиотеки с псевдонимом:
```python
import numpy as n
print(np.array([1,2,3]))
```
4. Импорт пользовательских модулей
Можно создавать свои модули, сохранив Python-стрипт с функциями и классами в отдельный файл и импортировав его в другие скрипты
```python 
# math_operations.py
def add(a,b):
	return a+b
def subtrack(a,b):
	return a - b

# main.py
import math_operations as mo

print(mo.add(10,5))
print(mo.subtrack(10,5))
```
## Продвинутые структуры данных: словари и множества (модуль collections)
Python предоставляет несколько продвинутых структур данных через модуль `collections`
1. `defaultdict`: словарь с значением по умолчанию для несуществующих ключей.
```python
from collections import defaultdict

dd = defaultdict(int)
dd["key1"] += 1
print(dd["key1"]) # 1
```
2. `counter`: подсчитывает количество вхождений элементов в коллекции.
```python
from collections import Counter

elements = ["a", "b", "a", "c", "b", "a"]
count = Counter(elements)
print(count) # COunter({'a': 3, 'b': 2, 'c': 1})
```
3. OrderDict: словарь, который сохраняет порядок добавления элементов
```python
from collections import OrderDict

od - OrderDict()
od["a"] = 1
od["b"] = 2
print(od) # OrderDict([('a',1), ('b':2))
```
4. deque: двухсторонняя очередь, которая поддерживает быстрые добавления и удаления с обоих концов.
```python
from collections import deque
d = deque([1,2,3])
d.appendleft(0)
d.append(4)
print(d) # deque([0,1,2,3,4])
```
## Обработка исключений
Обработка исключений позволяет предотвратить прерывание работы программы в случае возникновения ошибок
1. Конструкция `try-except`:
```python
try:
	result = 10/0
except ZeroDivisionError:
	print("Деление на ноль невозможно")
```
В этом примере при попытке деления на ноль возникает исключение `ZeroDivisionError`, и вместо аварийного завершения программы блок `except` обрабатывает ошибку выводя сообщение.
2. Использование `else`:
+ Блок `else` выполняется, если код внутри `try` не вызвал исключения 
```python
try:
	result = 10/2
except: ZeroDivisionError:
	print("Деление на ноль невозможно")
else:
	print("Результат:", result)
```
3. Блок `finally`
+ Блок `finally` выполняется независимо от того, что произошло исключение или нет. Обычно используется для завершения или очистки ресурсов.
```python
try:
	file = open("example.txt", "r")
	content = file.read()
except FileNotFoundError:
	print("Файл не найден")
finally:
	file.close()
```
4. Создание собственных исключений:
+ Можно создавать свои собственные исключения с помощью ключевого слова `raise`.
```python
def divide(a,b):
	if b == 0:
		raise ValueError("Делитель не может быть нулем")
	return a/b

try:
	result = divide(10, 0)
except ValueError as e:
	print(e)	
```
## Функции: аргументы, возвращаемые значения, lambda-функции
Функции в Python - это блоки кода, которые можно многократно использовать.
1. Определенные функции:
```python
def greet(name):
	return f"Hello, {name}!"

print(greet("Alice"))
```
2. Аргументы функции:
+ Функции могут принимать аргументы, которые передаются при их вызове.
```python
def add(a,b):
	return a+b

print(add(3,4))
```
3. Возвращаемые значения
+ Функция может возвращать значение с помощью ключевого слова `return`
```python
def square(x):
	return x**2

result = square(5)
print(result)
```
4. Аргументы по умолчанию
Можно задавать значения по умолчанию для аргументов.
```python
def greet(name="Guest"):
	return f"Hello, {name}!"

print(greet())
```
5. Lambda-функции - это небольшие анонимные функции, которые могут содержать только одно выражение.
```python
add = lambda x,y : x+y
print(add(5,3))
```
6. Передача функции как аргумента
+ Функции могут передаваться как аргументы другим функциям
```python
def apply_function(func, value):
	return func(value)
result = apply_function(lambda x:x+2)
print(result)
```
## Работа с файлами и контекстным менеджерами
Python предоставляет удобные инструменты для работы с файлами. 
1. Открытие и чтение файла:
```python
file = open("example.txt","r")
content = file.read()
print(content)
file.close()
```
2. Запись в файл:
```python
file = open("example.txt", "w")
file.write("Hello, World!")
file.close()
```
3. Контекстные менеджеры:
Использование конструкции `with` автоматически закрывает файл после завершения работы с ним.
```python
with open("example.txt","r") as file:
	content = file.read()
	print(content)
```
Контекстные менеджеры можно использовать не только для работы с файлами, но и в других ситуациях, требующих автоматического освобождения ресурсов.
## Генераторы и итераторы
Генераторы и итераторы позволяют создавать последовательности данных "на лету", что экономит память.
1. Итераторы:
		Итераторы - это объекты, которые поддерживают протокол итерации, т.е. имеют методы `__iter__() и __next__()`
```python
my_list = [1,2,3]
iterator = iter(my_list)

print(next(iterator))
print(next(iterator))
print(next(iterator))
```
2. Генераторы
		Генераторы создаются с помощью функции и ключевого слова `yield`
```python
def my_generator():
	yield 1
	yield 2
	yield 3

gen = my_generator()

print(next(gen))
print(next(gen))
print(next(gen))
```
Генераторы можно использовать для обработки больших объемов данных, так как они создают элементы по одному, по мере необходимости.

## Декораторы и рекурсивные функции
1. Декораторы - это функции которые принимают другую функцию и изменяют или расширяют ее поведение без изменения ее кода.
```python
def my_decorator(func):
	def wrapper():
		print("Что-то происходит до вызова функции")
		func()
		print("Что-то происходит после вызова функции")
	return wrapper

@my_decorator
def say_hello():
	print("Hello!")

say_hello()
```
В этом примере декоратор добавляет дополнительные действия до и после вызова функции `say_hello`
2. Рекурсивная функция - это функция, которая вызывает саму себя
```python
def factorial(n):
	if n==1:
		return 1
	else:
		return n * factorial(n-1)
```
Рекурсия полезна для решения задач, которые можно разбить на одинаковые подзадачи, вычисление факториала или обход дерева.

## Обработка коллекции с использованием `map` и `filter`
1. Функция `map` применяет заданную функцию ко всем элементам итерируемого объекта и возвращает итератор с результатами.
```python
numbers = [1,2,3,4,5]
squared = map(lambda x: x**2, numbers)
print(list(squared)) 
```
2. Функция `filter` фильтрует элементы итерируемого объекта по заданному условию.
```python
numbers = [1,2,3,4,5,6]
even_numbers = filter(lambda x: x % 2 == 0, numders)
print(list(even_numbers))
```
Эти функции помогают легко и элегантно обрабатывать коллекции данных в Python

