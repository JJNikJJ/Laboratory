## Заметка
Все сложные слова со сноской находятся в словаре. Ссылка на [[Словарь]]

# Определение и принципы ACID 
ACID - это набор свойств, которые обеспечивают надежность и согласованность транзакций в базе данных. Аббревиатура ACID расшифровывается как
1. Atomicity (Атомарность): Транзакция должна быть выполнена полностью или не выполнена вовсе. Если одна часть транзакции не может быть выполнена, вся транзакция откатывается.
2. Consistency (Согласованность): Транзакция должна переводить базу данных из одного согласованного состояния в другое. Если транзакция завершена успешно, то все правила и ограничения базы данных соблюдены.
3. Isolation (Изолированность): Транзакции должны вполняться так, как будто они являются единственными в системе. Одна транзакция не должна влиять на другие параллельно выполняемые транзакции.
4. Durabillity (Долговечность): После завершения транзакции и фиксации изменений, эти изменения сохраняются даже в случае сбоя системы.
# Основы работы с транзакциями в SQL
Транзакции в SQL - это последовательность операций, которые выполняются как единое целое. Если какая-либо часть транзакции не может быть завершена, транзакция должна быть отменена, и все изменения сделанные в ходе транзакции, откатываются.
## Пример:
```SQL
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2

COMMIT;
```
В этом примере мы сначала начинаем транзакцию, затем выполняем два обновления балансов на разных счетах, и если оба обновления выполнены успешно, транзакция фиксируется с помощью `COMMIT`
# COMMIT Транзакции
Команда `COMMIT` используется для фиксации всех изменений сделанных в ходе транзакции. После выполнния `COMMIT` все изменения становятся постоянными и доступны для других транзакций.
## Пример
```SQL
BEGIN TRANSACTION;
INSERT INTO orders (order_id, product_id, quantity) VALUES (1,101,2)
UPDATE inventory SET stock = stock - 2 WHERE product_id = 101;

COMMIT;
```
Этот пример вставляет новый заказ и обновляет количество товара на складе. После выполнения `COMMIT` эти изменения становятся постоянными.

# Применение механизма транзакций и сценарий использования
Транзакции используются в следующих случаях 
1. Многократные операции: Если несколько операций должны быть выполнены как единое целое.
2. Обработка ошибок: Для обеспечения согласованности данных, даже если одна из операций не удается.
3. Сложные операции: В случае сложных бизнес-логик, где требуется выполнение нескольких взаимосвязанных операций.
## Пример:
```SQL
BEGIN TRANSACTION; 

UPDATE employees SET salary = salary + 500 WHERE department = 'Sales';
UPDATE budget SET total = total - 500 WHERE department = 'Sales';

COMMIT;
```
Здесь увеличивается зарплата сотрудников отдела продаж и уменьшается бюджет отдела. Обе операции выполняются как одна транзакция.

# Механизм отката транзакции (ROLLBACK) и точки сохранения (savepoints)
Команда `ROLLBACK` используется для отмены всех изменений, сделанных в рамках текущей транзакции. Если произошла ошибка или транзакция должна быть отменена по другим причинам, `ROLLBACK` восстанавливает состояние базы данных до начала транзакции.
## Пример
```SQL
BEGIN TRANSACTION; 
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1
-- Ошибка : недостаточно средств на счете
IF @ERROR > 0
	ROLLBACK;
ELSE
	UPDATE account SET balance = balance + 100 WHERE account_id = 2
	COMMIT;
```
В этом примере если при снятии средств возникает ошибка, транзакция откатывается.

# Точки сохранения (savepoints):
`SAVEPOINT` позволяет создать промежуточную точку внутри транзакции, к которой можно откатиться, не прерывая всю транзакцию.
## Пример
```SQL
BEGIN TRANSACTION;
SAVEPOINT before_update;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;

-- Ошибка: недостаточно средств на счете
IF @ERROR > 0
	ROLLBACK TO before_update
ELSE
	UPDATE accounts SET balance = balane + 100 WHERE account_id = 2
	COMMIT;
```
В этом примере, если происходит ошибка после точки сохранения, изменения, сделанные до этой точки сохраняются, а се изменения после нее откатываются.

# Уровни изолированности транзакций и их влияние
Уровни изолированности транзакций определяют степень изолированности одной транзакции от другой. Различные уровни изолированности влияют на вероятность возникновения таких проблем как "грязное чтение", "неповторяющееся чтение" и "фантомное чтение".
## Основные уровни изолированности:
1. Read Uncommitted (Чтение незафиксированных данных): Самый низкий уровень изолированности. Транзакции могут видеть изменения, сделанные другими незавершенными транзакциями ,что может привести к "грязному чтению"
2. Read Committed (Чтение зафиксированных данных): Транзакция видит только изменения, зафиксированные другими транзакциями. Устраняет "грязное чтение", но не защищает от "неповторяющегося чтения".
3. Repeatable Read (Повторяемое чтение): Транзакция всегда видит одинаковые данные при повторном чтении одного и того же набора данных, даже если другие транзакции изменяют данные. Защищает от "грязного чтения" и "неповторяющегося чтения", но не защищает от "фантомного чтения".
4. Serializable (Сериализуемость): Самый высокий уровень изолированности. Гарантирует, что транзакции выполняются последовательно, одна за другой. Полностью предотвращает "грязное чтение", "неповторяющееся чтение" и "фантомное чтение", но может привести к снижению производительности.
## Пример настройки уровня изолированности
```SQL
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN TRANSACTION;

SELECT balance FROM account WHERE account_id = 1;

-- Другие операции

COMMIT;
```

Этот пример устанавливает уровень изолированности транзакции как `SERIALIZABLE`, что гарантирует максимальную изолированность.

# Примеры SQL-кода с использованием точек сохранения
## Пример
```SQL
BEGIN TRANSACTION;

INSERT INTO orders(order_id, customer_id, order_date) VALUES (1,1001, '2024-08-16');
SAVEPOINT after_insetr;

UPDATE inventory SET stock = stock - 10 WHERE product_id = 101;
IF @ERROR > 0
	ROLLBACK TO after_insert;
ELSE 
	COMMIT;
```
В этом примере, если последовательность возникает ошибка при обновлении инфентаря, транзакция откатывается к точке сохранения `after_insert`, сохраняя вставленный заказ.
# Механизмы обеспечения ACID  в распределенных системах управления базами данных
В распределенных системах управления транзакциями сложнее, так как необходимо обеспечить ACID-свойства в условиях распределенности данных. Для этого используются следующие механизмы:
1. Двухфазный коммит (2PC - Two-Phase Commit): Механизм используемый для обеспечения атомарности в распределенных транзакциях. Включает два этапа: подготовка и фиксация. В подготовку все узлы должны подтвердить готовность к коммиту. В фиксации транзакция либо фиксируется, либо откатывается на всех узлах.
2. Трехфазный коммит (3PC - Three-Phase Commit): Улучшенный вариант двухфазного коммита, который снижает вероятность блокировки узлов в случае отказа
3. Когерентные репликации и консенсус (Например, Raft, Paxos): Используется для согласования данных между узлами в распределенной системе, обеспечивая  консистентность и долговечность.
4. Оконные функции и версионирование данных: Используется для работы с последними версиями данных, что важно в условиях конкуренции за ресурсы в распределенных системах
## Пример двухфазного коммита
```SQL
-- ФАЗА 1: Подготовка 
PREPARE TRANSACTION 'txn1';

-- ФАЗА 2: Коммит или откат
COMMIT PREPARED 'txn1';
-- ИЛИ
ROLLBACK PREPARED 'txn1';
```
Этот пример демонстрирует основу двухфазного коммита, где транзакция сначала подготавливается а затем коммитится или откатывается.