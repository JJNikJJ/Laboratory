## Заметка
Все сложные слова со сноской находятся в словаре. Ссылка на [[Словарь]]
## SQL
Это язык структурированных запросов (Structured Query Language), позволяющий хранить, манипулировать и извлекать данные из реляционных баз данных

***

Он позволяет:
1. получать доступ к данным в системах управления РБД
2. Описывать данные и их структуру
3. определять данные в БД и управлять ими
4. взаимодействовать с другими языками через модули SQL, библиотеки и предварительные компиляторы
5. Создавать и удалять БД и таблицы
6. создавать представления, хранимые процедуры и функции в ЬД
7. устанавливать разрешения на доступ к таблицам, процедурам и представлениям.

***
## Процесс
При выполнении любой SQL-команды в любой RDBMS (Relational Database Management System - система выполнения РБД, СУБД, например, PostgreSQL, MySQL, MSSQL, SQLite и др.) система определяет наилучший способ выполнения запроса, а движок SQL определяет способ интерпретации задачи.

В данном процессе участвует несколько компонентов:
1. диспетчер запросов (Query Dispatcher)
2. Движок оптимизации (Optimization Engines)
3. классический движок запросов (Classic Query Engine)
4. движок запросов SQL (SQL Query Engine) и т.д.
Классический движок обрабатывает все не-SQL запросы, а движок SQL-запросов не обрабатывает логический файлы.

***
## Команды SQL
Стандартными командами для взаимодействия с РДБ являются 

* CREATE
* SELECT
* INSERT
* UPDATE
* DELETE
* DROP

Эти команды могут быть классифицированы следующим образом:

### DDL 
Это язык определения данных (Data Definition Language)

1. CREATE - создает новую таблицу, представление таблицы или другой объект в БД
2. ALTER - модифицирует существующий в БД объект, такой же как таблица
3. DROP - удаляет существующую таблицу, представление таблицы или другой объект в БД

### DML 
Это язык изменения данных (Data Manipulation Language)

* SELECT - извлекает записи из одной или нескольких таблиц
* INSERT - создает записи
* UPDATE - модифицирует записи
* DELETE - удаляет записи
### DCL
Это язык управления данными (Data Control Language)

* CRANT - наделяет пользователя правами
* REVOKE - отменяет права на пользователя

### TCL 
Это язык управления транзакциями (Transaction Control Language)

Транзакции используются для обеспечения целостности данных и позволяют выполнить несколько операций как одно целое.

* BEGIN или START TRANSACTION - начинает новую транзакцию. Все последующие команды SQL будут частью этой транзакции, пока не будет выполнена команда COMMIT или ROLLBACK
* COMMIT - фиксирует текущую транзакцию, то есть сохраняет все изменения сделанные в рамках транзакции в базы данных. После выполнения этой команды транзакция завершается.
* ROLLBACK - отменяет текущую транзакцию, откатывая все изменения, сделанные в ее рамках. После выполнения этой команды транзакция также завершается.
* SAVEPOINT - создает точку сохранения внутри транзакции, к которой можно откатиться, используя команду ROLLBACK TO SAVEPOINT. Это позволяет откатить только часть транзакции.
* ROLLBACK TO SAVEPOINT - откатывает транзакцию до указанной точки сохранения, созданной ранее с помощью команды SAVEPOINT.
* REALEASE SAVEPOINT - удаляет указанную точку сохранения. После этого откатиться к ней больше не будет возможно.

Эти команды используются для обеспечения надежности и согласованности операций с данными, особенно в ситуациях, когда происходит несколько изменений, которые должны быть выполнены как единое целое.

## Таблица, что это

Данные в СУБД хранятся в объектах БД, называемые таблицами (tables). Таблица, как правило, представляет собой коллекцию связанных между собой данных и состоит из определенного количества колонок и строк.

Таблица - это самая распространенная и простая форма хранения данных в РБД.

## Поле, что это?
Каждая таблица состоит из небольших частей - полей (fields).
Полями в таблице USERS являются **userID, userName, age, city и статус**. Поле - это колонка таблицы, предназначенная для хранения определенной информации о каждой записи в таблице. 

*Обратите внимание*: вместо **userID, userName** можно использовать **ID, NAME** соответственно. Но при работе с несколькими объектами, содержащими свойство **ID** бывает сложно понять, какому объекту принадлежит идентификатор, особенно, если вы, как и я, часто прибегаете к деструктуризации<sup>1</sup>

## Запись или строка, что это?

Запись или строка (record/row) - это любое единичное вхождение (entry), существующее в таблице. В таблице **USERS** - 5 записей. Проще говоря, запись - это горизонтальное вхождение в таблице.

## Колонка, что это?

Колонка (column) - это вертикальное вхождение в таблице, содержащее всю информацию, связанную с определенным полем. В таблице **USERS** одной из колонок является **city**, которая содержит названия городов, в которых проживают пользователи.

## Что такое нулевое значение?

Нулевое значение (NULL) - это значение поля, которое является пустым, т.е. нулевое значение отличается от значения **0** и от значения поля, содержащего пробелы.

___

Поле с нулевым значением - это такое поле, которое осталось пустым при создании записи. Также, следует учитывать, что в некоторых СУБД пустая строка (' ') - это NULL, а в некоторых - это разные значения.

---
## Ограничения
Constraints - это правила, применяемые к данным. Они используются для ограничения данных, которые могут быть записаны в таблицу. Это обеспечивает точность и достоверность данных в БД.

Ограничения могут устанавливаться как на уровне колонки, так и на уровне таблицы.
Среди наиболее распространённых ограничений можно назвать следующие:

* **NOT NULL** - колонка не может иметь нулевое значение
* **DEFAULT** - значение колонки по умолчанию
* **UNIQUE** - все значения колонки должны быть уникальными.
* **PRIMARY KEY** - первичный ключ или основной ключ, уникальный идентификатор записи в текущей таблице.
* **FOREIGIN KEY** - внешний ключ, уникальный идентификатор записи в другой таблице (таблице, связанной с текущей)
* **CHECK** - все значения в колонке должны удовлетворять определенному условию
* **INDEX** - быстрая запись и извлечение данных. 
Любое ограничение может быть удалено с помощью команды **ALTER TABLE** и **DROP CONSTRANT** + название ограничения. Некоторые реализации предоставляют сокращения для удаления ограничений и возможность отключать ограничения вместо их удаления.

## Целостность данных
В каждой СУБД существуют следующие категории целостности данных:
* Целостность объекта (Entity Interrity) - в таблице не должно быть дубликатов<sup>2</sup>
* Целостность домена (Domain Integrity) - фильтрация значений по типу, формату или диапазону.
* Целостность строки (Referential Integrity) - строки, используемые другими записями (строки, на которые в других записях имеются ссылки) не могут быть удалены
* Целостность, определенная пользователем (User-Defined Integrity) - дополнительные правила
## Нормализация БД

Нормализация - это процесс эффективной организации данных в БД. Существует две главные причины, обуславливающих необходимость нормализации:

* предотвращение записи в БД лишних данных, например, хранение одинаковых данных в разных таблицах
* обеспечение "оправданной" связи между данными
Нормализация предполагает соблюдение нескольких форм. Форма - это формат структурированной БД. Существуют три главные формы: первая, вторая и третья.

Каждая форма нормализации - это шаг к более структурированной и организованной базе данных. Наиболее важными и часто применяемыми являются три первых формы нормализации

### Первая форма нормализации (1NF)

<b> Требования </b>
1. Все столбцы должны содержать атомарные значения, то есть значения, которые неделимы. Например, в одном столбце не должно храниться сразу несколько значений, таких как список телефонных номеров.
2. Все строки в таблице должны быть уникальными, что достигается использованием первичного ключа.
3. В таблице не должно быть повторяющихся групп (множеств столбцов с одинаковыми или схожими данными)
Пример

| ID  | NAME       | PHONES             |
| --- | ---------- | ------------------ |
| 1   | John Doe   | 123-4567, 234-5678 |
| 2   | Jane Smith | 345-6789           |
Здесь столбец "PHONES" нарушает 1NF, так как содержит несколько значений. ЧТобы привести таблицу к 1NFЮ нужно разделить телефоны на отдельные строки:

| ID  | Name         | Phone    |
|-----|--------------|----------|
| 1   | John Doe     | 123-4567 |
| 1   | John Doe     | 234-5678 |
| 2   | Jane Smith   | 345-6789 |
### Вторая нормальная форма (2NF) 

<b> Требования</b>
1. Таблица должна соответствовать требованиям 1NF. 
2. Все не ключевые атрибуты (столбцы) должны зависить от всего первичного ключа а не только от его части (если первичный ключ составной). 
   Это значит, что не должно быть частичных зависимостей. 

Предположим у нас есть таблица с составным ключом (ID + Course) и атрибутом, зависящим только от одного из ключей.

| ID  | COURSE  | INSTRUCTOR | DEPARTAMENT |
| --- | ------- | ---------- | ----------- |
| 1   | Math    | Dr. Brown  | Science     |
| 1   | History | Dr. Green  | Humanities  |
Здесь атрибут "DEPARTAMENT" зависит только от "COURSE", а не от составного ключа (ID + COURSE). Чтобы привести таблицу к 2NF, нужно разделить ее на две:

Таблица 1 (Студенты и курсы):

| ID  | Course  | Instructor |
| --- | ------- | ---------- |
| 1   | Math    | Dr. Brown  |
| 1   | History | Dr. Green  |

Таблица 2 (Курсы и департаменты):

| Course       | Department |
|--------------|------------|
| Math         | Science    |
| History      | Humanities |
###  Третья нормальная форма (3NF) 

<b>Требования</b>
1. Таблица должна соответствовать требованиям 2NF.
2. Некачественные атрибуты не должны зависеть друг от друга, то есть не должно быть транзитивных зависимостей. Все не ключевые атрибуты должны зависеть только от первичного ключа. 
Пример: 
Рассмотрим таблицу, где "DEPARTMENTHEAD" зависит от "DEPARTMENT"

| Course       | Department | DepartmentHead |
|--------------|------------|----------------|
| Math         | Science    | Dr. White      |
| History      | Humanities | Dr. Black      |

Здесь "DEPARTMENTHEAD" транзитивно зависит от "COURSE" через "DEPARTMENT". Чтобы привести таблицу к 3NF, разделим ее на две:

Таблица 1 (Курсы и департаменты):

| Course       | Department |
|--------------|------------|
| Math         | Science    |
| History      | Humanities |

Таблица 2 (Департаменты и их главы):

| Department   | DepartmentHead |
|--------------|----------------|
| Science      | Dr. White      |
| Humanities   | Dr. Black      |

## Синтаксис SQL

Синтаксис - это уникальный набор правил и рекомендаций. Все инструкции SQL должны начинаться с ключевого слова, такого как **SELECT, INSERT, UPDATE, DELETE, ALTER, DROP, CREATE, USE, SHOW** и т.д. и заканчиваться точкой с запятой ( *;* ). При этом точка с запятой не входит в синтаксис SQL, но ее наличия, как правило, требуют консольные клиенты СУБД для обозначения окончания ввода команды). SQL не чувствительный к регистру, т.е. SELECT, select, SEleCt являются идентичными инструкциями. Исключением из этого является правила MySQL, где учитывается регистр в названии таблицы

Приведем пару примеров:

TODO 
Сделать потом

## Типы данных

Каждая колонка, переменная и выражение в SQL имеют определенный тип данных (data type)
 Основные категории типов данных:

<b>Точные числовые</b>
+ bigint
+ int 
+ smallint
+ tinyint
+ bit
+ decimal
+ numeric
+ money
+ smallmoney
<b>Приблизительно числовые</b>
+ float
+ real
<b> Дата и время</b>
+ datetime 
+ smalldatetime
+ date - сохраняется в виде m/d/y
+ time - сохраняется в виде h:m P.M. / A. M
<b>Строковые символьные</b> (не юникод)
+ char 
+ varchar
+ text
<b> Строковые символьные </b>(юникод)
+ nchar
+ nvarchar
+ ntext
<b>Бинарные</b>
+ binary
+ varbinary
+ image
<b>Смешанные</b>
+ timestamp - уникальные сила, обновляющиеся при каждом изменении строки
+ uniqueidentifier- глобально-уникальные идентификатор (GUID)
+ cursor - объект курсора
+ table - промежуточный результат, предназначенный для дальнейшей обработки

## Операторы
Операторы (operators) - это ключевое слово или символ, которые, в основном, используются в инструкциях **WHERE** для выполнения каких-либо операций. Они используются как для определения условий, так и для объединение нескольких условий в инструкции.
Предположим, что а = 10, b = 20.

#### <b> Арифметические </b>

| Оператор                         | Описание                                                            | Пример      |
| -------------------------------- | ------------------------------------------------------------------- | ----------- |
| + (сложение)                     | Сложение значений                                                   | a + b = 30  |
| — (вычитание)                    | Вычитание правого операнда из левого                                | b — a = 10  |
| * (умножение)                    | Умножение значений                                                  | a * b = 200 |
| / (деление)                      | Деление левого операнда на правый                                   | b / a = 2   |
| % (деление с остатком/по модулю) | Деление левого операнда на правый с остатком (возвращается остаток) | b %         |
#### <b> Операторы сравнения </b>
|Оператор|Описание|Пример|
|---|---|---|
|=|Определяет равенство значений|a = b -> false|
|!=|Определяет НЕравенство значений|a != b -> true|
|<>|Определяет НЕравенство значений|a <> b -> true|
|>|Значение левого операнда больше значения правого операнда?|a > b -> false|
|<|Значение левого операнда меньше значения правого операнда?|a < b -> true|
|>=|Значение левого операнда больше или равно значению правого операнда?|a >= b -> false|
|<=|Значение левого операнда меньше или равно значению правого операнда?|a <= b -> true|
|!<|Значение левого операнда НЕ меньше значения правого операнда?|a !< b -> false|
|!>|Значение левого операнда НЕ больше значения правого операнда?|a !> b -> true|
#### <b> Логические операторы </b>
|N|Оператор|Описание|
|---|---|---|
|1|ALL|Сравнивает все значения|
|2|AND|Объединяет условия (все условия должны совпадать)|
|3|ANY|Сравнивает одно значение с другим, если последнее совпадает с условием|
|4|BETWEEN|Проверяет вхождение значения в диапазон от минимального до максимального|
|5|EXISTS|Определяет наличие строки, соответствующей определенному критерию|
|6|IN|Выполняет поиск значения в списке значений|
|7|LIKE|Сравнивает значение с похожими с помощью операторов подстановки|
|8|NOT|Инвертирует (меняет на противоположное) смысл других логических операторов, например, NOT EXISTS, NOT IN и т.д.|
|9|OR|Комбинирует условия (одно из условий должно совпадать)|
|10|IS NULL|Определяет, является ли значение нулевым|
|11|UNIQUE|Определяет уникальность строки|

## Выражения (Expression)
Это комбинация значений, операторов и функций для оценки (вычисления) значения. Выражения похожи на формулы, написанные на языке запросов. Они могут использоваться для извлечения из БД определенного набора данных.
Базовый синтаксис выглядит следующим образом:

```sql
SELECT col1, col2, ..., colN
FROM tableName
WHERE [condition|expression]
```
Существуют различные типы выражений:
+ Логические
+ Числовые
+ Выражения для работы с датами

#### <b>Логические</b>
Извлекают данные на основе совпадения с единичным значением
```SQL
SELECT col1, col2, ..., colN
FROM tableName
WHERE <выражение для поиска совпадения с единичным значением> ;
```
Предположим, что в таблице **Users** имеются следующие записи:

|userId|userName|age|city|status|
|---|---|---|---|---|
|1|Igor|25|Moscow|active|
|2|Vika|26|Ekaterinburg|inactive|
|3|Elena|27|Ekaterinburg|active|
|4|Oleg|28|Moscow|inactive|
```SQL
# Выполняем поиск активных пользователей
SELECT * FROM users WHERE status = active
```
Результат

| userId | userName | age | city         | status |
| ------ | -------- | --- | ------------ | ------ |
| 1      | Igor     | 25  | Moscow       | active |
| 3      | Elena    | 27  | Ekaterinburg | active |
#### **Числовые**
Используются для выполнения арифмитических операций в запросе.
```SQL
SELECT numericalExpression as operarionName
[FROM tableName
WHERE condition]
```
Простой пример использования числового выражения:
```SQL
SELECT (10 + 5) as addition
```
Результат

| addition |
| -------- |
| 15       |
#### **Агрегирующие функции**
Существуют несколько встроенных функций, таких как **count(), sum(), avg(), min(), max() и др.** для выполнения так называемых агрегирующих вычислений данных таблицы или колонки.
```SQL
SELECT COUNT(*) as records FROM users
```

| records |
| ------- |
| 4       |
+ AVG - вычисляет среднее значение
+ SUM - вычисляет сумму значений
+ MIN - вычисляет наименьшее значение
+ MAX - вычисляет наибольшее значение
+ COUNT - вычисляет количество записей в таблице

Также существует несколько встроенных функций для работы со строками:
+ CONCAT - объединение строк
+ LENGTH - возвращает количество символов в строке
+ TRIM - удаляет пробелы в начале и конце строки
+ SUBSTRING - извлекает подстроку из строки
+ REPLACE - заменяет подстроку в строке
+ LOWER - переводит символы строки в нижний регистр
+ UPPER - переводит символы строки в верхний регистр
Для работы с числами:
+ ROUND - округляет число
+ TRUNCATE - обрезает дробное число до указанного количества знаков после запятой
+ CELLING -  возвращает наименьшее целое число, которое больше или равно текущему значению.
+ FLOOR - возвращает наибольшее целое число, которое меньше или равно текущему значению
+ POWER - возводит число в указанную степень
+ SQRT - возвращает квадратный корень числа
+ RAND - генерирует случайное число с плавающей точной в диапазоне от 0 до 1
#### **Выражения для работы с датами **

Эти выражения, как правило, возвращают текущую дату и время.
```SQL
SELECT CURRENT_TIMESTAMP
```

| Current_Timestamp   |
| ------------------- |
| 2024-08-13 12:57:32 |
CURRENT_TIMESTAMP - это и выражение, и функция (CURRENT_TIMESTAM()). Другая функция для получения текущей даты и времени - NOW().

Другие функции для получения текущей даты и времени:
+ CURDATE/CURRENT_DATE - возвращает текущую дату
+ CURTIME/CURRENT_TIME - возвращает текущее время и т.д.

Функции для разбора даты и времени:
+ DAYOFMONTH(date) - возвращает день месяца в виде числа
+ DAYOFWEEK(date) - возвращает день недели в виде числа
+ DAYOFYEAR(date) - возвращает номер дня в году
+ MONTH(date) - возвращает месяц
+ YEAR(date) - возвращает год
+ LAST_DAY(date) - возвращает последний день месяца в виде даты
+ HOUR(date) - возвращает час
+ MINUTE(date) - возвращает минуты
+ SECOND(date) - возвращает секунды
Функции для манипулирования датами:
+ DATE_ADD(date, interval) - выполняет сложение даты и определенного временного интервала
+ DATE_SUB(date, interval) - выполняет вычитание из даты определенного временного интервала
+ DATEDIFF(date1, date2) - возвращает разницу в днях между двумя датами.
+ TO_DAYS(data) - возвращает количество дней с 0-го дня года
+ TIME_TO_SEC(time) - возвращает количество секунд с полуночи и др.
Для форматирования даты и времени используются функции DATE_FORMAT(date, format) и TIME_FORMAT(date, format)

## Создание БД
Для создания БД используется инструкция CREATE DATABASE. 
```SQL
CREATE DATABASE dbName;
-- или
CREATE DATABASE IF NOT EXISTS dbNAme;
```
Условие IF NOT EXISTS позволяет избежать получения ошибки при попытке создания БД, которая уже существует.

Название БД должно быть уникальным в пределах СУБД.

Создаем БД testDB: 
```SQL
CREATE DATABASE testDB;
```
Получаем список БД
```SQL
SHOW DATABASES;
```
Результат:

|Database|
|---|
|information_schema|
|postgres|
|testDB|
## Удаление БД

Для удаления БД используется инструкция DROP DATABASE.
```SQL
DROP DATABASE dbName;
-- или
DROP DATABASE IF EXISTS dbName;
```
Условие IF EXISTS позволяет избежать получения ошибки при попытке удаления несуществующей БД

**Действия**
Удаляем testDB
```SQL
DROP DATABASE testDB
```
При удалении БД уничтожаются все данные которые в ней хранятся, так что нужно быть внимательным при использовании данной команды.

Проверяем что БД удалена:
```SQL
SHOW DATABASE
```
Для получения списка таблиц используется инструкция SHOW TABLES.
Результат:

| Database           |
| ------------------ |
| information_schema |
| postgres           |
## Выбор БД
При наличии нескольких БД перед выполнением каких-либо операций, необходимо выбрать БД. Для этого используется инструкция USE/
```SQL
USE dbName
```
Предположим, что мы не удаляли testDB. Тогда мы можем выбрать ее так:
```SQL
USE testDB;
```

## Создание таблицы

Создание таблицы предполагает указание названия таблицы и определение колонок таблицы и их типов данных. Для создания используется инструкция CREATE TABLE.

```SQL
CREATE TABLE tableName(
col1 datatype,
col2 datatype,
...
colN datatype,
PRIMARY KEY -- хотя бы одна колонка
);
```
Для создания таблицы путем копирования другой таблицы используется сочетание CREATE TABLE и SELECT.

Пример создания таблицы users, где первичным ключом являются идентификаторы пользователей, а поля для имени и возраста пользователя не могут быть нулевыми:
```SQL
CREATE TABLE users(
userID INT,
userNAME VARCHAR(20) NOT NULL,
age INT NOT NULL,
city VARCHAR(20),
status VARCHAR(20),
PRIMARY KEY (id),
);
```
Проверяем что таблица была создана:
```SQL
DESC users
```
Результат:

| Field    | Type        | Null | Key | Default | Extra |
| -------- | ----------- | ---- | --- | ------- | ----- |
| userId   | int(11)     | NO   | PRI |         |       |
| userName | varchar(20) | NO   |     |         |       |
| age      | int(11)     | NO   |     |         |       |
| city     | varchar(20) | NO   |     |         |       |
| status   | varchar(8)  | YES  |     | NULL    |       |

## Удаление таблицы

Для удаления таблицы используется инструкция DROP TABLE.

При удалении таблицы навлегда удаляются все хранящиеся в ней данные, индексы, триггеры, ограничения и разрешения, так что нужно быть предельно внимательным
Удаляем таблицу users:
```SQL
DROP TABLE users;
```
Теперь если попытаться получить описание users, то получим ошибку
```SQL
DESC users;
-- ERROR 1146 (42S02): Table 'testDB.users' doesn't exist
```

## Добавление колонок
Для добавления в таблицу колонок используется инструкция INSERT INTO

```SQL
INSERT INTO tableName(col1, col2, ..., colN)
VALUES (val1, val2, ..., valN);
```
Навания колонок можно не указывать, однако, в этом случае значения должны перечисляться в правильном порядке.
```SQL
INSERT INTO tableName VALUES (val1, val2, ..., valN);
```
Во избежание ошибок, рекомендуется всегда перечислять названия колонок.

Предположи, что мы не удаляли таблицу users. Заполним ее пользователями:

```SQL
INSERT INT users (userID, userName, age, city, status) 
VALUES (1, 'Igor', 25, 'Moscow', 'active')

INSERT INT users (userID, userName, age, city, status) 
VALUES (2, 'Vika', 26, 'Saint-Petersburg', 'inactive')

INSERT INT users (userID, userName, age, city, status) 
VALUES (3, 'Elena', 27, 'Ekaterinburg', 'active')
```

ИЛИ
```SQL
INSERT INT users (userID, userName, age, city, status) 
VALUES 
(1, 'Igor', 25, 'Moscow', 'active')
(2, 'Vika', 26, 'Saint-Petersburg', 'inactive')
(3, 'Elena', 27, 'Ekaterinburg', 'active')
```
Также, как было отмечено, при добавлении строки названия полей можно опустить
```SQL
INSERT INTO users
VALUES (4, 'Oleg', 28, 'Moscow', 'inactive')
```
Результат

| userId | userName | age | city             | status   |
| ------ | -------- | --- | ---------------- | -------- |
| 1      | Igor     | 25  | Moscow           | active   |
| 2      | Vika     | 26  | Saint-Petersburg | inactive |
| 3      | Elena    | 27  | Ekaterinburg     | active   |
| 4      | Oleg     | 28  | Moscow           | inactive |
Заполнение таблицы с помощью другой таблицы
```SQL
INSERT INTO tableName[(col1, col2, ..., colN)]
SELECT col1, col2, ..., colN
FROM anotherTable
[WHERE condition];
```

## Выборка полей
Для выборки полей из таблицы используется инструкция SELECT. Она возвращает данные в виде результирующей таблицы (результирующего набора, result-set). 
```SQL
SELECT col1, col2, ..., colN
FROM tableName;
```
Для выборки всех полей используется звездочка *

Произведем выборку полей userID, userName и age из таблицы users:
```SQL
SELECT userID, userName, age FROM users;
```
Результат

|userId|userName|age|
|---|---|---|
|1|Igor|25|
|2|Vika|26|
|3|Elena|27|
|4|Oleg|28|
## Предложение WHERE
Предложение WHERE используется для фильтрации возвращаемых данных. Оно используется совместно с SELECT, UPDATE, DELETE и другими инструкциями.
```SQL
SELECT col1, col2, ..., colN
FROM tableName
WHERE condition;
```
Условие (condition), которому должны удволетворять возвращаемые записи, определяется с помощью опираторов сравнения или логических операторов типа **>, <, =, NOT, LIKE** и т.д.

Сделаем выборку полей userID, userName и age активных пользователей
```SQL
SELECT userID, userName, age
FROM users
WHERE status = 'active'
```
Результат:

|userId|userName|age|
|---|---|---|
|1|Igor|25|
|3|Elena|27|
Сделаем выборку полей userID, age и city пользователя Vika
```SQL
SELECT userID, age, city
FROM users
WHERE userName = 'Vika'
```
Результат

|userId|age|city|
|---|---|---|
|2|26|Ekaterinburg|
## Операторы AND и OR
Конъюнктивный оператор AND и дизъюнктивный оператор OR используются для соединения нескольких условий при фильтрации данных.

**AND**
```SQL
SELECT col1, col2, ..., colN
FROM tableName
WHERE condition1 and condition2 ... and conditionN
```
Возвращаемые записи должны удволетворять всем указанным условиям.

Сделаем выборку полей userID, userName и age активных пользователей старше 26 лет:
```SQL
SELECT userID, userName, age
FROM users
WHERE status = 'active' and age > 26; 
```
Результат

| userId | userName | AGE |
| ------ | -------- | --- |
| 3      | Elena    | 27  |

**OR**
```SQL
SELECT col1, col2, ...colN
FROM tableName
WHERE condition1 OR condition2 ...OR conditionN;
```
Возвращаемые записи должны удовлетворять хотя бы одному условию.

Сделаем выборку тех же полей неактивных пользователей или пользователей, младше 27 лет.

```SQL
SELECT userID, userName, age
FROM users
WHERE status = 'inactive' or age < 27
```
Результат:

|userId|userName|age|
|---|---|---|
|1|Igor|25|
|2|Vika|26|
## Обновление полей

Для обновления полей используется инструкция UPDAE ... SET. Эта инструкция, обычно, используется в сочетании с предложением WHERE
```SQL
UPDATE tableName
SET col1 = val1, col2 = val2, ... colN = valN
[WHERE condition];
```

Обновим возраст пользователя с именем 'Igor'
```SQL
UPDATE users
SET age = 30
WHERE username = 'Igor'
```
Если мы не пропишем условие то будет обновлен возраст всех пользователей

## Удаление записей

Для удаления записей используется конструкция DELETE. Эта инструкция также, как правило, используется в сочетании с предложением WHERE.
```SQL
DELETE FROM tableName
[WHERE condition];
```
Удалим неактивных пользователей
```SQL
DELETE FROM users
WHERE status = 'inactive'
```
Если в данном случае опустить WHERE, то из таблицы users будут удалены все записи.

## Предложения LIKE и REGEX

**LIKE**
Предложение LIKE используется для сравнения значений с помощью операторов с подстановочными знаками. Существует два вида таких операторов:
+ проценты (%)
+ нижнее подчеркивание ( _ )
Проценты означает 0, 1 или более символов. _ означает точно один символ
```SQL
SELECT col1, col2, ... colN FROM tableName
WHERE col LIKE 'xxx%'

SELECT col1, col2, ... colN FROM tableName
WHERE col LIKE '%xxx%'

SELECT col1, col2, ... colN FROM tableName
WHERE col LIKE '%xxx'

SELECT col1, col2, ... colN FROM tableName
WHERE col LIKE 'xxx_'
```
Примеры 

|N|Инструкция|Результат|
|---|---|---|
|1|WHERE col LIKE 'foo%'|Любые значения, начинающиеся с `foo`|
|2|WHERE col LIKE '%foo%'|Любые значения, содержащие `foo`|
|3|WHERE col LIKE '_oo%'|Любые значения, содержащие `oo` на второй и третьей позициях|
|4|WHERE col LIKE 'f_%_%'|Любые значения, начинающиеся с `f` и состоящие как минимум из 1 символа|
|5|WHERE col LIKE '%oo'|Любые значения, оканчивающиеся на `oo`|
|6|WHERE col LIKE '_o%o'|Любые значения, содержащие `o` на второй позиции и оканчивающиеся на `o`|
|7|WHERE col LIKE 'f_o'|Любые значения, содержащие `f` и `o` на первой и третьей позициях, соответственно, и состоящие из трех символов|
Сделаем выборку неактивных пользователей
```SQL
SELECT * FROM users
WHERE status LIKE 'in%'
```
Результат

| userId | userName | age | city         | status   |
| ------ | -------- | --- | ------------ | -------- |
| 2      | Vika     | 26  | Ekaterinburg | inactive |
| 4      | Oleg     | 28  | Moscow       | inactive |
Сделаем выборку пользователей 30 лет и старше
```SQL
SELECT * FROM users
WHERE age LIKE '3_'
```
Результат

|userId|userName|age|city|status|
|---|---|---|---|---|
|1|Igor|30|Moscow|active|
REGEX
Предложение REGEX позволяет определять регулярные выражение, которому должна соответствовать запись.
```SQL
SELECT col1, col2, ...colN
FROM tableName
WHERE colName REGEXP --регулярное выражение--
```
В регулярном выражении могут использоваться следующие специальные символы
+ ^ - начало строки
+ $ - конец строки
+ . - любой символ
+ [] - любой из указанных в скобках символов
+ [] c указанием начала и конца - любой символ из диапазона
+ | - разделяет шаблоны
Сделаем выборку пользователей и именами Igor и Vika
```SQL
SELECT * FROM users
WHERE userName REGEXP 'Igor | Vika'
```
Результат

|userId|userName|age|city|status|
|---|---|---|---|---|
|1|Igor|30|Moscow|active|
|2|Vika|26|Ekaterinburg|inactive|
## Предложение TOP / LIMIT / ROWNUM

Данные предложения позволяют извлекать указанное количество или процент записей с начала таблицы. Разные СУБД поддерживают разные предложения

```SQL
SELECT TOP number percent col1, col2, ...colN
FROM tableName
[Where condition];
```
Сделаем выборку первых трех пользователей:
```SQL
SELECT TOP 3 * FROM users;
```
Результат

|userId|userName|age|city|status|
|---|---|---|---|---|
|1|Igor|30|Moscow|active|
|2|Vika|26|Ekaterinburg|inactive|
|3|Elena|27|Ekaterinburg|active|
В MySQL:
```SQL
SELECT * FROM users
LIMIT 3, [offset];
```
Параметр offset (смещение) определяет количество пропускаемых записей. Например так можно извлечь первых двух пользователей, начиная с третьего:
```SQL
SELECT * FROM users
LIMIT 2,2;
```

## Предложения ORDER BY и GROUP BY

**ORDER BY** 
Предложение ORDER BY используется для сортировки данных по возрастанию (ASC) или убыванию (DESK)
Многие СУБД по умолчанию выполняют сортировку по возрастанию.

```SQL
SELECT col1, col2, ... colN
FROM tableName
[WHERE condition]
[ORDER BY col1, col2, ...colN] [ASC | DESC]
 ```
 Колонки для сортировки должны быть указаны в списке колонок для выборки
Сделаем выборку пользователей отсортировав их по городу и возрасту: 
```SQL
SELECT * FROM users
ORDER BY city, age;
```
Результат:

|userId|userName|age|city|status|
|---|---|---|---|---|
|2|Vika|26|Ekaterinburg|inactive|
|3|Elena|27|Ekaterinburg|active|
|1|Igor|25|Moscow|active|
|4|Oleg|28|Moscow|inactive|

Теперь выполним сортировку по убыванию:
```SQL
SELECT * FROM users
ORDER BY city, age DESC;
```
Определим собственный порядок сортировки по убыванию
```SQL
SELECT * FROM users
ORDER BY (CASE city 
		 WHEN 'Ekaterinburg' THEN 1
		 WHEN 'Moskow' THEN 2
		 ELSE 100 END) ASC. city DESC
```
**GROUP BY**
Предложение GROUP BY используется совместно с инструкцией SELECT для группировки записей. Оно указывается после WHERE и перед ORDER BY
```SQL
SELECT col1, col2, ...colN
FROM tableName
WHERE condition
GROUP BY col1, col2, ...colN
ORDER BY col1, col2, ...colN
```
Сгруппируем активных пользователей по городам:
```
SELECT city, COUNT(city) as amount FROM users
WHERE status = 'active'
GROUP BY city
ORDER BY city;
```
Результат:

| city         | amount |
| ------------ | ------ |
| Ekaterinburg | 2      |
| Moscow       | 2      |
## Ключевое слово DISTINCT

Ключевое слово DISTINCT используется совместно с инструкцией SELECT для возврата только уникальных записей (без дубликатов)
```SQL
SELECT DISTINCT col1, col2, ...colN
FROM tableName
[WHERE condition];
```
Сделаем выборку городов проживания пользователей:
```SQL
SELECT DISTINCT city
FROM users;
```

Результат

| city         |
| ------------ |
| Ekaterinburg |
| Moscow       |

## Соединения JOIN

Соединения (JOIN) используются для комбинации записей двух и более таблиц.
Предположим что кроме users, у нас имеется таблица orders c заказами пользователей следующего вида: 

|orderId|date|userId|amount|
|---|---|---|---|
|101|2021-06-21 00:00:00|2|3000|
|102|2021-06-20 00:00:00|2|1500|
|103|2021-06-19 00:00:00|3|2000|
|104|2021-06-18 00:00:00|3|1000|
Сделаем выборку полей userID, userName, age и amount из наших таблиц посредством их соединения:
```SQL
SELECT userID, userName, age, amount
FROM users, orders
WHERE users.usersID = orders.usersID
```
Результат

|userId|userName|age|amount|
|---|---|---|---|
|2|Vika|26|3000|
|2|Vika|26|1500|
|3|Elena|27|2000|
|3|Elena|27|1000|
При соединение таблиц могут использоваться такие операторы как =, <, >, <>, <=, >=, !=, BETWEEN, LIKE и NOT, однако наиболее распространенным является =.
Существуют разные типы объединений:

+ INNER JOIN - возвращает записи, имеющиеся в обеих таблицах
+ LEFT JOIN - возвращает записи из левой таблицы, даже если такие записи отсутствуют в правой таблице
+ RIGHT JOIN - возвращает записи из правой таблицы даже если такие записи отсутствуют в левой таблицу 
+ FULL JOIN - возвращает все записи объединяемых таблиц
+ CROSS JOIN - возвращает все возможные комбинации строк обеих таблиц.
+ SELF JOIN - используется для объединения таблицы с самой собой

## Предложения UNION

Предложение/оператор UNION используется для комбинации результатов двух или более инструкций SELECT. При этом, возвращаются только уникальные записи.

В случае с UNION, каждая инструкция SELECT должна иметь:
+ одинаковый набор колонок для выборки
+ одинаковое количество выражений
+ одинаковые типы данных колонов
+ одинаковый порядок колонок
Однако, они могут быть разной длины:
```SQL
SELECT col1, col2, ... colN
FROM table1
[WHERE condition]

UNION

SELECT col1, col2, ...colN
FROM table2
[WHERE condition]
```
Объединим наши таблицы users и orders:
```SQL 
SELECT userID, userName, amount, date
FROM users
LEFT JOIN orders
ON users.userID = orders.userID
UNION
SELECT userID, userName, amount, date
FROM users
RIGHT JOIN orders
ON users.userID = orders.userID;
```
Результат:

|userId|userName|amount|date|
|---|---|---|---|
|1|Igor|NULL|NULL|
|2|Vika|3000|2021-06-21 00:00:00|
|2|Vika|1500|2021-06-20 00:00:00|
|3|Elena|2000|2021-06-19 00:00:00|
|3|Elena|1000|2021-06-18 00:00:00|
|4|Alex|NULL|NULL|
## Предложение UNION ALL

Предложение UNION ALL также используется для объединения результатов двух и более инструкций SELECT. 
При этом, возвращаются все записи, включая дубликаты
```SQL
SELECT col1, col2, ...colN
FROM table1
[WHERE condition]
UNION ALL
SELECT col1, col2, ...colN
FROM table2
[WHERE condition];
```
Существует еще два предложения, похожих на UNION: 
+ INTERSECT - используется для комбинации результатов двух и более SELECT, но возвращаются только строки из первого SELECT, совпадающего со строками из второго SELECT
+ EXCEPT | MINUS - возвращаются только строки из первого SELECT, отсутствующие во втором SELECT
## Синонимы

Синонимы (aliases) позволяют временно изменять названия таблиц и колонок. "Временно" означает, что новое название используется только в текущем запросе, в БД название остается прежним.

Синтаксис синонима таблицы:
```SQL
SELECT col1, col2, ...colN
FROM tableName AS aliasName
[WHERE condition];
```
Синтаксис синонима колонки
```
SELECT colName AS aliasName
FROM tableName
[WHERE condition];
```
Пример использования синонимов таблиц:
```SQL
SELECT U.userID, U.userName, U.age, O.amount
FROM users AS U, orders AS O
WHERE U.userID = O.userID
```
Результат

| userId | userName | age | amount |
| ------ | -------- | --- | ------ |
| 2      | Vika     | 26  | 3000   |
| 2      | Vika     | 26  | 1500   |
| 3      | Elena    | 27  | 2000   |
| 3      | Elena    | 27  | 1000   |

Пример использования синонимов колонок:
```SQL
SELECT userID AS user_id, userName AS user_name, age AS user_age
FROM users
WHERE status = 'active'
```
Результат:

| user_id | user_name | user_age |
| ------- | --------- | -------- |
| 1       | Igor      | 30       |
| 3       | Elena     | 27       |
## Индексы
### Создание индексов
Индексы - это специальные поисковые таблицы (lookup tables), которые используются движком БД в целях более быстрого извлечения данных. Проще говоря, индекс - это указатель или ссылка на данные в таблице.

Индексы ускоряют работу инструкции SELECT и предложения WHERE, но замедляют работу инструкции UPDATE и INSERT. Индексы могут создаваться и удаляться, не оказывая никакого влияния на данные.

Для создания индекса используется инструкция CREATE INDEX, позволяющая определять название индекса, индексируемые колонки и порядок индексации (по возрастанию или по убыванию)

К индексам можно применять ограничение UNIQUE для того, чтобы обеспечить их уникальность.

Синтаксис создания индекса:
```SQL 
CREATE INDEX indexName ON tableName;
```
Синтаксис создания индекса для одной колонки
```SQL
CREATE INDEX indexName
ON tableName (colName);
```
Синтаксис создания индексов для нескольких колонок (композиционный индекс):
```SQL
CREATE INDEX indexName
ON tableName (col1, col2, ...colN)
```
Решение о создании индексов для одной или нескольких колонок следует принимать на основе того, какие колонки будут часто использоваться в запросе WHERE в качестве условия для сортировки строк.

Для ограничений PRIMARY KEY и UNIQUE автоматически создаются неявные индексы.

### Удаление индексов
Для удаления индексов используются инструкция DROP INDEX:
```SQL
DROP INDEX indexName;
```
Несмотря на то, что индексы предназначены для повышения производительности БД, существует ситуации в которых их использования лучше избежать

К таким ситуациям относится следующее:
+ индексы не должны использоваться в маленьких таблицах
+ в таблицах, которые часто и в большом объеме обновляются или перезаписываются
+ в колонках, которые содержат большое количество нулевых значений
+ в колонках, над которыми часто выполняются операции

## Обновление таблицы

Команда ALTER TABLE используется для добавления, удаления и модификации колонок существующей таблицы. Также эта команда используется для добавления и удаления ограничений

Синтаксис:
```SQL
-- Добавление новой колонки
ALTER TABLE tableName ADD colName datatype;
-- удаление колонки
ALTER TABLE tableName DROP COLUMN colName; 
-- изменение типа данных колонки
ALTER TABLE tableName MODIFY COLUMN colName newDataType;
-- добавление ограничения NOT NULL
ALTER TABLE tableName MODIFY colName datatype NOT NULL;
-- добавление ограничения 'UNIQUE'
ALTER TABLE tableName
ADD CONSTRAINT muUniqueConstraint CHECK (condition);
-- добавление первичного ключа 
ALTER TABLE tableName
ADD CONSTRAINT myPrimaryKey PRIMARY KEY (col1, col2, ... colN)
-- удаление ограничения 
ALTER TABLE tableName
DROP CONSTRAINT myUniqueConstraint;
-- mysql
ALTER TABLE tableName
DROP INDEX myUniqueConstraint
-- удаление первичного ключа 
ALTER TABLE tableName
DROP CONSTRAINT MyPrimaryKey;
-- mysql
ALTER TABLE tableName
DROP PRIMARY KEY;
```
Добавляем в таблицу users новую колонку - пол пользователя:
```SQL 
ALTER TABLE users ADD sex char(1);
```
Удаляем эту колонку:
```SQL
ALTER TABLE users DROP sex;
```


