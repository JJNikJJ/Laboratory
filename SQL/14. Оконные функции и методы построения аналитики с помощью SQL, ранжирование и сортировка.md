## Заметка
Все сложные слова со сноской находятся в словаре. Ссылка на [[Словарь]]
## Основы оконных функций в SQL
Оконные функции (windows function) в SQL позволяют выполнять вычисления над набором строк, которые связаны с текущей строкой. Эти функции отличаются от обычных агрегатных функций тем, что не группируют строки в одной строку, а возвращают значение для каждой строки на основе ее окружения
Основные оконные функции включают:
1. ROW_NUMBER(): Возвращает уникальный номер строки в пределах набора строк.
2. RANK(): Возвращает ранг строки в пределах набора строк, оставляя пропуски при совпадении значений
3. DENSE_RANK(): Похож на RANK(), но без пропусков ранжировании.
4. NTILE(): Разбивает набор строк на заданное количество групп (квантилей) и возвращает номер группы для каждой строки.
5. LEAD() и LAG(): Позволяют получать значение из следующей или предыдущей строки в рамках набора строк.
## Применение ключевого слова OVER
Ключевое слово OVER используется для опеределения окна, в пределах которого будет применяться оконная функция. Оно определяет, какие строки будут включены в окно для вычисления.
```SQL
SELECT employees_id, department, salary,
	RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank
FROM employees
```
Этот запрос ранжирует сотрудников в каждом отделе на основе их зарплаты. `PARTITION BY DEPARTMENT` делит строки на группы по департаментам, а `ORDER BY salary DESC` сортирует их по убыванию зарплаты.
## Базовая сортировка и фильтрации результатов в SQL
Сортировка и фильтрация данных - это важные операции, которые используются для организации и отбора данных. SQL предлагает оператор ORDER BY для сортировки данных и WHERE для фильтрации.
```SQL
SELECT name, dapartment, salary
FROM employees
WHERE department = 'IT'
ORDER BY salary DESC
```
этот запрос фильтрует сотрудников, работающих в IT, и сортирует их по убыванию зарплаты.
## Различие между ROW_NUMBER(), RANK() и DENSE_RANK()
Это три оконные функции используются для ранжирования строк, но у них есть важные различия
1. ROW_NUMBER() - присваивает уникальный номер каждой строке в рамках набора строк, начиная с 1. Даже при одинаковых значениях в столбце, номера строк будут уникальными.
```SQL
SELECT name, salary, 
	ROW_NUMBER() OVER (ORDER BY salary DESC) as row_number
FROM employees;
```
2. RANK() Присваивает одинаковый ранг строкам с одинаковыми значениями, но пропускает следующие ранги
```SQL
SELECT name, salary,
	RANK() OVER (ORDER BY salary DESC) as rank
FROM employees
```
 3. DENSE_RANK(): Похож на RANK(), но не пропускает ранги после одинаковых значений.
 ```SQL
 SELECT name, salary,
	 DENSE_RANK() OVER (ORDER BY salary DESC) as dense_rank
FROM employees;
```
Использование PARTITION BY в оконных функциях
PARTITION BY используется для разделения набора данных на подгруппы, к которым применяется оконная функция. Это позволяет выполнять вычисления по отдельным группам строк, а не по всему набору данных.
### Пример
```SQL
SELECT employee_id, department, salary,
	ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as row_num
FROM employees;
```
Этот запрос нумерует сотрудников в каждом департаменте по убыванию их зарплаты.
## Вычисление скользящего среднего с помощью оконных функций
Скользящее среднее (movig average) можно рассчитать с использованием оконных функций, таких как AVG(), OVER(). Это полезно для анализа данных во времени или при необходимости сглаживания значений.
### Пример:
```SQL
SELECT order_date, sales,
	AVG(sales) OVER (ORDER BY order_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as moving_avg
FROM sales_data;
```
Этот запрос вычисляет скользящее среднее по продажам за текущую и две предыдущие строки
## Ранжирования данных с помощью функции RANK()
Функция RANK() используется для ранжирования строк в пределах набора данных. Она присваивает одинаковый ранг строкам с одинаковыми значениями, но оставляет пропуски в номерах рангов.
### Пример:
```SQL
SELECT name, department, salary,
	RANK() OVER (PARTITION BY department ORDER BY salary DESC) as rank
FROM emoloyees;
```
Этот запрос ранжирует сотрудников в каждом отделе на основе их зарплаты.
## Разбиение данных на квантили с NTILE()
Функция NTILE() разбивает строки на равные группы (квантили) и присваивает каждой строке номер группы.
### Пример
```SQL
SELECT name, salary,
	NTILE(4) OVER (ORDER BY salary DESC) as quartile
FROM employees;
``` 
Этот запрос разбивает сотрудников на 4 группы по уровню зарплаты.
## Оптимизация запросов с оконными функциями
Оптимизация оконных функций может включать использование индексов, сокращение количества строк в окне и правильное использование PARTITION BY и ORDER BY для минимизации вычислительной нагрузки.
### Пример
```SQL
CREATE INDEX idx_salary ON employees(department, salary DESC);
```
Этот индекс ускорит выполнение запросов, использующих PARTITION BY department и ORDER BY salary DESC/
## Анализ последовательных строк данных с LEAD() и LAG()
Функции LEAD() и LAG() позволяют получить значение из следующей или предыдущей строки в наборе данных.
### Пример
```SQL
SELECT name, salary
	LAG(salary, 1) OVER (ORDER BY salary DESC) as prev_salary,
	LEAD(salary, 1) OVER (ORDER BY salary DESC ) as next_salary
FROM employees;
```
Этот запрос возвращает зарплату текущей строки, а также зарплату предыдущей и следующей строки
## Кумулятивная сумма с условием и оконные функции
Кумулятивная сумма (cumulative sum) рассчитывается с помощью функции SUM(), OVER(), которая суммирует значения по мере прохождения строк.
### Пример
```SQL
SELECT order_date, sales,
	SUM(sales) OVER (ORDER BY order_date ROWS UNBOUNDED PRECEDING) as cumulative_sales
FROM sales_data;
```
Этот запрос вычисляет кумулятивные продажи по дате заказа.
## Комплексное аналитическое ранжирование с несколькими критериями
